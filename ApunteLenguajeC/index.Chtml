<HTML>
<HEAD>
	<TITLE>cc31a</TITLE>
	<META NAME="AUTHOR" CONTENT="Patricio Poblete">
	<STYLE>
	<!--
		H1 { font-family: "helvetica", sans-serif; text-align: left }
		H2 { font-family: "helvetica", sans-serif; text-align: left }
		H3 { font-family: "helvetica", sans-serif; text-align: left }
		TD { font-family: "helvetica", sans-serif }
		P { font-family: "helvetica", sans-serif }
		TT { font-family: "courier" }
		PRE { font-family: "courier" }
	-->
	</STYLE>
</HEAD>
<BODY bgcolor=white>
<table width=100% bgcolor=wheat><tr><td>
<center>
<font size="+3"><b>cc31a Desarrollo de Software de Sistemas</b></font>
<p>
<i>
Patricio Poblete
(<A HREF="mailto:ppoblete@dcc.uchile.cl">ppoblete@dcc.uchile.cl</A>)
</i>
</center>
</td></tr></table>

<p>
<H1>Introducción al Lenguaje C</H1>
<p>
<ol>
<li><a href="#1">Un primer programa</a>
<li><a href="#2">Entrada/salida de caracteres</a>
<li><a href="#3">Arreglos</a>
<li><a href="#4">Funciones</a>
<li><a href="#5">Arreglos de caracteres</a>
<li><a href="#6">Variables externas</a>
<li><a href="#7">Conversiones de caracteres</a>
<li><a href="#8">Operaciones con bits</a>
<li><a href="#9">Prioridad de Operadores</a>
<li><a href="#10">Instrucciones de Control</a>
<li><a href="#11">Punteros y Arreglos</a>
<li><a href="#12">Memoria Dinámica</a>
<li><a href="#13">Argumentos para el programa</a>
<li><a href="#14">Estructuras</a>
<li><a href="#15">Typedef</a>
<li><a href="#16">Uniones</a>
<li><a href="#17">Entrada/Salida</a>
<li><a href="#18">setjmp/longjmp</a>
<li><a href="#19">Punteros a funciones</a>
<li><a href="#20">Funciones con un número variable de parámetros</a>
<li><a href="#21">La Biblioteca Standard de Entrada/Salida</a>
</ol>
<p>
<a name="1"><h2>Un primer programa</h2></a>
<p>
El siguiente es un programa que al ejecutarse escribe
<tt>Hola</tt> en la pantalla:

<program hola.c>
#include <stdio.h>

main()
  {
    printf("Hola\n");
  }
</program>

Para compilar y ejecutar este programa se utilizan los comandos siguientes:
<p>
<pre><b>
            % cc hola.c
            % ./a.out
</b></pre>
<p>
<i>Ejemplo</i>: Conversión Fahrenheit-Celsius (C=(5/9)*(F-32))

<program fahrenheit.c>
#include <stdio.h>

/* Imprime tabla Fahrenheit-Celsius */

main()
  {
    int f, c;
    int min, max, step;

    min=0;
    max=300;
    step=20;

    f=min;
    while(f<=max)
      {
        c=5*(f-32)/9;
        printf("%d\t%d\n", f, c);
        f=f+step;
      }
  }
</program>
<p>
Versión más compacta:
<program>
for(f=min; f<=max; f+=step)
    printf("%d\t%d\n", f, 5*(f-32)/9);
</program>
<p>
Tipos de datos:
<p>
<pre><b>
    int
    float
    char
    short
    long
    double
</b></pre>
<p>
Para tener más precisión podemos declarar <tt>f</tt> como <tt>float</tt>:
<p>
<program>
float f;

for(f=min; f<=max; f+=step)
    printf("%3.0f %6.1f\n", f, (5.0/9.0)*(f-32.0));
</program>
<p>
Constantes simbólicas:
<p>
<program>
#define MIN 0
#define MAX 300
#define STEP 20

for(f=MIN; f<=MAX; f+=STEP)
    . . .
</program>
<p>
Reuniendo todo lo anterior, tenemos la siguiente versión para el programa:
<p>
<program fahrenheit2.c>
#include <stdio.h>

#define MIN 0
#define MAX 300
#define STEP 20

/* Imprime tabla Fahrenheit-Celsius */

main()
  {
    float f;

    for(f=MIN; f<=MAX; f+=STEP)
        printf("%3.0f %6.1f\n", f, (5.0/9.0)*(f-32.0));
  }
</program>

<p>
<a name="2"><h2>Entrada/salida de caracteres</h2></a>
<p>
<program>
int c; /* debe declararse int, no char */

c = getchar();  /* lee desde la entrada standard */
                /* retorna EOF al llegar al fin de archivo */
putchar(c);
</program>
<p>
<i>Ejemplo:</i> Copiar entrada hacia salida
<p>
<program copia.c>
#include <stdio.h>

/* Copiar entrada hacia salida */

main()
  {
    int c;

    c=getchar();
    while(c!=EOF)
      {
        putchar(c);
        c=getchar();
      }
  }
</program>
<p>
Versión más compacta:
<p>
<program copia2.c>
#include <stdio.h>

/* Copiar entrada hacia salida */

main()
  {
    int c;

    while((c=getchar())!=EOF)
        putchar(c);
  }
</program>
<p>
Hay que tener cuidado con la parentización. Lo siguiente
<program>
while(c=getchar() != EOF)
</program>
<p>
estaría mal, porque el operador <tt>!=</tt> tiene mayor prioridad que
la asignación.
<p>
<i>Uso:</i>
<p>
<pre><b>
        % ./a.out
                             Lee del teclado y escribe en pantalla

        % ./a.out &lt;arch1
                             Copia de arch1 a la pantalla

        % ./a.out &lt;arch2 >arch2
                             Copia de arch1 a arch2

        % ./a.out >arch2
                             Guarda en arch2 lo que se tipea en el teclado
</b></pre>
<p>
<i>Ejemplo:</i>
<p>
<program cuentac.c>
/* Cuenta caracteres */

#include <stdio.h>

main()
  {
    int nc;

    nc=0;
    while(getchar()!=EOF)
        ++nc;

    printf("%d\n", nc);
  }
</program>
<p>
<p>
<i>Ejemplo:</i>
<p>
<program cuental.c>
/* Cuenta líneas */

#include <stdio.h>

main()
  {
    int c, nl;

    nl=0;
    while((c=getchar())!=EOF)
        if(c=='\n')
            ++nl;

    printf("%d\n", nl);
}
</program>
<p>
<i>Otras instrucciones:</i>
<p>
<program>
      if(    )                  if(    )
        {                         {
          . . .                     . . .
        }                         }
                                else
                                  {
                                    . . .
                                  }
</program>

<p>
<a name="3"><h2>Arreglos</h2></a>
<p>
<i>Ejemplo:</i> Contar cuantas veces aparece cada dígito.
<p>
Para esto, llevamos un conjunto de 10 contadores, para cada uno
de los dígitos. Esto es un arreglo <tt><b>a</b></tt>en donde el contador
asociado al dígito
<tt><b>c</b></tt> es
<tt><b>a[c-'0']</b></tt>.
<p>
<program cuentad.c>
/* Cuenta dígitos */

#include <stdio.h>

main()
  {
    int c, i;
    int a[10];

    for(i=0; i<=9; ++i)
        a[i]=0;

    while((c=getchar())!=EOF)
        if(c>='0' && c<='9')
            ++a[c-'0'];

    for(i=0; i<=9; ++i)
        printf("%d    %d\n", i, a[i]);
  }
</program>

<p>
<a name="4"><h2>Funciones</h2></a>
<p>
<i>Ejemplo:</i> Elevación a potencia (cálculo de a<sup>n</sup>)
<p>
<program potencia.c>
#include <stdio.h>

/* Función que calcula elevación a potencia */
int potencia(int a, int n)
  {
    int i, p;

    p=1;
    for(i=1; i<=n; ++i)
        p*=a;

    return p;
  }

/* Programa de prueba que imprime potencias de 2 y de -3 */
main()
  {
    int i;

    for(i=0; i<=10; ++i)
        printf("%2d %6d %6d\n",
            i, potencia(2,i), potencia(-3,i));

    return 0; /* para indicar fin OK */
  }
</program>
<p>
El traspaso de parámetros es por valor.
Los parámetros son variables locales y pueden ser modificados sin
problema.
<p>
<program>
int potencia(int a, int n)
  {
    int p;

    for(p=1; n>0; --n)
        p*=a;

    return p;
  }
</program>
<p>
<a name="5"><h2>Arreglos de caracteres</h2></a>
<p>
Para almacenar un string se usa un arreglos de <tt><b>char</b>s</tt>,
marcando el fin del string con un caracter nulo
(<tt><b>'\0'</b></tt>).
Una constante de tipo string (<tt><b>"..."</b></tt>)
tiene automáticamente un caracter nulo al final.
<p>
<i>Ejemplo</i>: Encontrar el largo de la línea más larga
<program maxlinea.c>
#include <stdio.h>

#define MAXLINEA 1000

/* Lee una linea en arreglo s de largo máximo lim */
/* Retorna 0 si encuentra fin de archivo */
int getline(char s[], int lim)
  {
    int c, i;

    for(i=0; i<lim-1
          && (c=getchar())!=EOF
          && c!='\n'; ++i)
        s[i]=c;
    if(c=='\n')
      {
        s[i]=c;
        ++i;
      }
    s[i]='\0';

    return i;
  }

/* Programa que imprime el largo de la línea más larga */
main()
  {
    int largo, maxlargo;
    char linea[MAXLINEA];

    maxlargo=0;
    while((largo=getline(linea, MAXLINEA))>0)
        if(largo>maxlargo)
            maxlargo=largo;

    printf("La línea más larga tiene %d caracteres\n", maxlargo);
  }
</program>
¿Cómo imprimir <i>la</i> línea más larga?
<p>
Para recordar la línea más larga no basta con hacer
<program>
char larga[MAXLINEA];

...

if(largo>maxlargo)
  {
    maxlargo=largo;
    larga=linea;              /* ERROR */
  }
</program>
porque esto no copia los caracteres.
En lugar de ello, habría que llamar a una función que copia los
caracteres uno por uno:
<p>
<i>Ejemplo</i>: Encontrar la línea más larga
<program maxlinea2.c>
#include <stdio.h>

#define MAXLINEA 1000

/* Copia desde -> hacia */
void copia(char hacia[], char desde[])
  {
    int i;

    for(i=0; (hacia[i]=desde[i])!='\0'; ++i)
        ;
  }

/* Lee una linea en arreglo s de largo máximo lim */
/* Retorna 0 si encuentra fin de archivo */
int getline(char s[], int lim)
  {
    int c, i;

    for(i=0; i<lim-1
          && (c=getchar())!=EOF
          && c!='\n'; ++i)
        s[i]=c;
    if(c=='\n')
      {
        s[i]=c;
        ++i;
      }
    s[i]='\0';

    return i;
  }

/* Programa que imprime la línea más larga */
main()
  {
    int largo, maxlargo;
    char linea[MAXLINEA], larga[MAXLINEA];

    maxlargo=0;
    while((largo=getline(linea, MAXLINEA))>0)
        if(largo>maxlargo)
          {
            maxlargo=largo;
            copia(larga, linea);
          }

    printf("La línea más larga es:\n%s\n", larga);
  }
</program>
<p>
En realidad hay funciones predefinidas para realizar algunas
de estas operaciones de strings.
<p>
En lugar de <tt><b>getline</b></tt> se usa
<program>
char[] fgets(char s[], int max, FILE *stream)
</program>
Al llamar a esta función, si queremos que lea de su entrada standard,
hay que invocarla con <tt><b>stdin</b></tt> como tercer parámetro.
<p>
Las siguientes funciones requieren incluir un nuevo archivo de encabezamiento:
<program>
#include <string.h>
</program>
En lugar de <tt><b>copia</b></tt> se usa
<program>
char[] strcpy(char to[], char from[])
</program>
y para calcular el largo de un string se puede usar
<program>
int strlen(char s[])
</program>
<i>Ejemplo</i>: Imprime la línea más larga.
<program maxlinea3.c>
/* Programa que imprime la línea más larga */

#include <stdio.h>
#include <string.h>

#define MAXLINEA 1000

main()
  {
    int largo, maxlargo;
    char linea[MAXLINEA], larga[MAXLINEA];

    maxlargo=0;
    while(fgets(linea, MAXLINEA, stdin)!=NULL)
      {
        largo=strlen(linea);
        if(largo>maxlargo)
          {
            maxlargo=largo;
            strcpy(larga, linea);
          }
      }

    printf("La línea más larga es:\n%s\n", larga);
  }
</program>
<p>
<a name="6"><h2>Variables externas</h2></a>
<p>
Las variables declaradas fuera de las funciones son
almacenadas estáticamente y pueden ser accesadas desde las funciones.
<p>
<i>Ejemplo</i>:
<program>
int x;

f()
  {
    extern x;

    /* aquí se puede usar x */
  }
</program>
La declaración dentro de la función se puede omitir si la declaración
externa está dentro del mismo archivo.
<p>
<a name="7"><h2>Conversiones de caracteres</h2></a>
<p>
Al incluir el archivo
<program>
#include <stdlib.h>
</program>
se pueden utilizar funciones como <tt><b>atoi(s)</b></tt>, que convierte
un string a entero ("ascii to int"), <tt><b>atol(s)</b></tt> ("ascii
to long"), etc.
<p>
La siguiente es una implementación posible de <tt><b>atoi</b></tt>:
<program>
/* atoi: convierte string ascii a entero */
int atoi(char s[])
  {
    int i, n;

    n=0;
    for(i=0; s[i]>='0' && s[i]<='9'; ++i)
        n=n*10+(s[i]-'0');

    return n;
  }
</program>
Al incluir el archivo
<program>
#include <ctype.h>
</program>
se pueden utilizar funciones como <tt><b>tolower(c)</b></tt>, que convierte
un caracter de mayúsculas a minúsculas, <tt><b>isdigit(c)</b></tt>,
que dice si el carácter es un dígito decimal, <tt><b>isalpha(c)</b></tt>,
que dice si es un carácter alfabético, etc.
<p>
<i>Ejemplo</i>: Implementación de <tt><b>tolower</b></tt>:
<program>
int tolower(int c)
  {
    if(c>='A' && c<='Z')
        c=c-'A'+'a';

    return c;
  }
</program>
<p>
<a name="8"><h2>Operaciones con bits</h2></a>
<p>
Los enteros se almacenan internamente en binario. Por ejemplo:
<pre>
(2001)<sub>10</sub> = (111 1101 0001)<sub>2</sub>

         = 2<sup>10</sup>+2<sup>9</sup>+2<sup>8</sup>+2<sup>7</sup>+2<sup>6</sup>+2<sup>4</sup>+2<sup>1</sup>

         = 1024+512+256++128+64+16+1
</pre>
<p>
En C se usa notación octal y hexadecimal. En octal, los bits se agrupan de
a 3:
<pre>
(2001)<sub>10</sub> = (11 111 010 001)<sub>2</sub> = (3721)<sub>8</sub> = 03721
</pre>
y en hexadecimal se agrupan de a 4:
<pre>
(2001)<sub>10</sub> = (111 1101 0001)<sub>2</sub> = (7d1)<sub>16</sub> = 0x7d1
</pre>
<p>
<b>Operadores binarios </b>
<table>
<tr><td><tt><b>&amp;</b></tt></td><td>and</td></tr>
<tr><td><tt><b>|</b></tt></td><td>or</td></tr>
<tr><td><tt><b>^</b></tt></td><td>xor</td></tr>
<tr><td><tt><b>&lt;&lt;</b></tt></td><td>shift left</td></tr>
<tr><td><tt><b>>></b></tt></td><td>shift right</td></tr>
<tr><td><tt><b>~</b></tt></td><td>complement</td></tr>
</table>
<p>
<i>Ejemplos</i>:
<program>
n = n & 0x7f;      /* deja sólo los 7 bits inferiores */
x = x | MASK;      /* enciende todos los bits en 1 de MASK */
x = x & ~MASK;     /* apaga todos los bits que están en 1 en MASK */
</program>
<p>
<i>Ejemplo</i>: Otra implementación para <tt><b>tolower</b></tt>.
<br>
Considerando que las el rango <tt>A..Z</tt> es <tt>0x41..0x5A</tt>
y que el rango <tt>a..z</tt> es <tt>0x61..0x7A</tt>, entonces
podemos escribir:
<program>
int tolower(int c)
  {
    if(c>='A' && c<='Z')
        c |= 0x20;

    return c;
  }
</program>
<p>
<a name="9"><h2>Prioridad de Operadores</h2></a>
<p>
<table>
<tr><th>Operadores</th><th>Asociatividad</th></tr>
<tr><td><tt>()  []  ->  .</tt></td><td>izquierda</td></tr>
<tr><td><tt>!  ~  ++  --  +  -  *  &amp;  (tipo)  sizeof</tt></td><td>derecha</td></tr>
<tr><td><tt>*  /  %</tt></td><td>izquierda</td></tr>
<tr><td><tt>+  -</tt></td><td>izquierda</td></tr>
<tr><td><tt>&lt;&lt;  >></tt></td><td>izquierda</td></tr>
<tr><td><tt>&lt;  &lt;= >  >=</tt></td><td>izquierda</td></tr>
<tr><td><tt>==  !=</tt></td><td>izquierda</td></tr>
<tr><td><tt>&amp;</tt></td><td>izquierda</td></tr>
<tr><td><tt>^</tt></td><td>izquierda</td></tr>
<tr><td><tt>|</tt></td><td>izquierda</td></tr>
<tr><td><tt>&amp;&amp;</tt></td><td>izquierda</td></tr>
<tr><td><tt>||</tt></td><td>izquierda</td></tr>
<tr><td><tt>?:</tt></td><td>derecha</td></tr>
<tr><td><tt>=  +=  -=  *=  /=  %=  &amp;=  ^=  |=  &lt;&lt;=  >>=</tt></td><td>derecha</td></tr>
<tr><td><tt>,</tt></td><td>izquierda</td></tr>
</table>
<p>
<a name="10"><h2>Instrucciones de Control</h2></a>
<p>
C tiene esencialmente las mismas instrucciones de control que ya hemos visto
en Java:
<program>
if
while
break
continue
...
</program>
<p>
Además existe una instrucción <tt><b>goto</b></tt> que se usa
con muy poca frecuencia.
<p>
La instrucción <tt><b>switch</b></tt> permite seleccionar entre
múltiples casos:
<pre><b>
        switch( expr )
          {
        case valor<sub>1</sub>:  /* llega aquí si expr==valor<sub>1</sub> */
            ...
            ...
            break;  /* de lo contrario sigue de largo */
        
        case valor<sub>2</sub>:  /* llega aquí si expr==valor<sub>2</sub> */
            ...
            ...
            break;  /* de lo contrario sigue de largo */

            ...
            ...

        default:    /* llega aquí si no es ninguno de los anteriores */
            ...
            ...
          }
</b></pre>
<p>
La instrucción <tt><b>do</b></tt> es similar al <tt><b>while</b></tt>,
pero la comparación se hace al final de cada iteración:
<program>
do
  {
    ...
    ...
  }
while( expr );
</program>
<p>
<a name="11"><h2>Punteros y Arreglos</h2></a>
<p>
La siguiente instrucción asigna a <tt><b>p</b></tt> un puntero
a la variable <tt><b>x</b></tt>:
<program>
int x;
int *p;

p = &x;  /* p apunta a x */
</program>
<p>
La operación opuesta permite obtener el valor apuntado por <tt><b>p</b></tt>:
<program>
y = *p;  /* Equivalente a y=x */

*p = 0;  /* Equivalente a x=0 */
</program>
<p>
Esto permite escribir una función que interambia los valores de sus
dos parámetros:
<p>
<program intercambia.c>
void intercambia(int *px, int *py)
  {
    int aux;

    aux=*px;
    *px=*py;
    *py=aux;
  }

main()
  {
    int a=1, b=2;

    printf("ANTES:   a=%d b=%d\n", a, b);

    intercambia(&a, &b);  /* NO intercambia(a, b) */

    printf("DESPUES: a=%d b=%d\n", a, b);
  }
</program>
<p>
<b>Relación con arreglos</b>
<p>
<program>
int a[10];
int *p;
</program>
<p>
<center>
<table border=1>
<tr>
<td><tt>a[0]</tt></td>
<td><tt>a[1]</tt></td>
<td><tt>....</tt></td>
<td><tt>a[9]</tt></td>
</table>
</center>
<p>
<program>
p = &a[0];  /* p apunta al primer elemento de a */

printf("%d\n", *(p+1));  /* imprime a[1] */

printf("%d\n", *(p+i));  /* imprime a[i] */
</program>
<p>
Además
<program>
p = &a[0];
</program>
es equivalente a
<program>
p = a;
</program>
de modo que
<pre><b>
        *(a+i)  <i>es equivalente a</i>  a[i]
</b></pre>
<p>
<i>Ejemplo</i>: Cálculo del largo de un string
<program largo.c>
int my_strlen(char *s)
  {
    int n;

    for(n=0; *s!='\0'; ++s)
        ++n;

    return n;
  }

main()
  {
    printf("%d\n", my_strlen("hola"));
  }
</program>
<p>
Implementación alternativa usando aritmética de punteros:
<program largo2.c>
int my_strlen(char *s)
  {
    char *p=s;

    while(*p!='\0')
        ++p;

    return p-s;
  }

main()
  {
    printf("%d\n", my_strlen("hola"));
  }
</program>
<p>
<b><tt>Strcpy</tt> con y sin punteros</b>
<p>
<program copias1.c>
/* Versión con arreglos */

#include <stdio.h>

void my_strcpy(char s[], char t[])
  {
    int i;

    i=0;
    while((s[i]=t[i])!='\0')
        ++i;
  }

main()
  {
    char a[10];

    my_strcpy(a, "hola");
    printf("%s\n", a);
  }
</program>
<p>
<program copias2.c>
/* Versión con punteros */

#include <stdio.h>

void my_strcpy(char *s, char *t)
  {
    while((*s=*t)!='\0')
      {
        ++s;
        ++t;
      }
  }

main()
  {
    char a[10];

    my_strcpy(a, "hola");
    printf("%s\n", a);
  }
</program>
<p>
<program copias3.c>
/* Versión con punteros (más compacta) */

#include <stdio.h>

void my_strcpy(char *s, char *t)
  {
    while((*s++=*t++)!='\0')
        ;
  }

main()
  {
    char a[10];

    my_strcpy(a, "hola");
    printf("%s\n", a);
  }
</program>
<p>
<program copias4.c>
/* Versión con punteros (más compacta todavía) */

#include <stdio.h>

void my_strcpy(char *s, char *t)
  {
    while(*s++=*t++)
        ;
  }

main()
  {
    char a[10];

    my_strcpy(a, "hola");
    printf("%s\n", a);
  }
</program>
<p>
<a name="12"><h2>Memoria Dinámica</h2></a>
<p>
La función básica es <tt><b>malloc</b></tt>, que reserva un espacio de memoria
del tamaño que se le indique (en bytes) y retorna un puntero.
Siempre hay que anteponerle un cast a la llamada, para que el tipo del
puntero retornado se adapte a lo que se espera.
<program>
#include <stdlib.h>

char *s;

s = (char *)malloc(100); /* reserva un área de 100 bytes */
</program>
<p>
Para pedir espacio para un arreglo hay dos alternativas.
Una es usar <tt><b>malloc</b></tt> y calcular "a mano" el espacio
total requerido. Por ejemplo,
<program>
p = (int *)malloc(100*sizeof(int)); /* p apunta a un arreglo de 100 int's */
</program>
<p>
La otra forma es usar otra función, <tt><b>calloc</b></tt>, que tiene
dos parámetros (número de celdas y tamaño de cada celda):
<program>
p = (int *)calloc(100, sizeof(int)); /* p apunta a un arreglo de 100 int's */
</program>
<p>
Un efecto lateral de <tt><b>calloc</b></tt> es que inicializa en cero la
memoria que entrega.
<p>
Al terminar de usar un área de memoria pedida dinámicamente, se la debe
retornar al sistema usando
<program>
free(p);
</program>
<p>
donde <tt><b>p</b></tt> apunta al principio del área que se libera.
<p>
En C no hay recolección automática de basura, es responsabilidad del
programador liberar la memoria que ya no use.
Los programas que funcionan durante mucho tiempo y que van olvidando
liberar memoria se dice que tienen un error de tipo "memory leak", el
cual puede ser muy difícil de investigar.
<p>
<i>Ejemplo</i>:
<program reves.c>
/* Lee un archivo y lo imprime al revés */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LARGOMAX 1000
#define MAXLINEAS 10000

main()
  {
    char linea[LARGOMAX];
    char *a[MAXLINEAS];  /* arreglo de punteros a las líneas */
    int k;

    /* primero leemos las lineas */

    for(k=0; fgets(linea, LARGOMAX, stdin)!=NULL; ++k)
      {
        if(k>=MAXLINEAS)
          {
            fprintf(stderr, "Archivo demasiado grande\n");
            exit(-1);
          }
        a[k]=strdup(linea);  /* Construye una copia del string */
      }

    /* ahora las imprimimos al reves */

    while(k-->0)
       fputs(a[k], stdout);
  }
</program>
<p>
La función <tt><b>strdup</b></tt> reserva un espacio de memoria del
tamaño exacto para copiar allí el string que recibe como argumento, lo copia
y retorna un puntero a esa área.
La siguiente función sería equivalente:
<program>
char *my_strdup(char *s)
  {
    char *p;

    p=(char *)malloc(strlen(s)+1);

    if(p!=NULL)
        strcpy(p,s);

    return p;
  }
</program>
<p>
<a name="13"><h2>Argumentos para el programa</h2></a>
<p>
El encabezamiento del programa es
<program>
main(int argc, char *argv[])
</program>
<p>
El arreglo <tt><b>argv</b></tt> tiene <tt><b>argc</b></tt> elementos,
los cuales son punteros a los strings que son las palabras de la línea
de comandos, comenzando por <tt><b>argv[0]</b></tt>, que es el nombre
del comando.
<p>
<center>
<img src="argv.gif">
</center>
<p>
<i>Ejemplo</i>:
<program my_echo.c>
main(int argc, char *argv[])
  {
    int i;

    for(i=1; i<argc; ++i)
        printf("%s%c", argv[i], (i<argc-1?' ':'\n'));
  }
</program>

<p>
<a name="14"><h2>Estructuras</h2></a>
<p>
Una estructura (o record) agrupa a un conjunto de campos.
<program>
/* Definición de la estructura */
struct punto
  {
    float x;
    float y;
  };

/* Declaraciones de variables */
struct punto u, v;
struct punto z={1.0, -2.5};

/* Acceso a componentes */
z.x=2.0;
printf("z=(%f, %f)\n", z.x, z.y);
</program>
<p>
<b>Punteros a Estructuras</b>
<p>
<program>
struct punto *p;

p=&z;

printf("%f\n", (*p).x); /* los paréntesis son necesarios por la prioridad */


printf("%f\n", p->x);   /* notación alternativa más simple */
</program>
<p>
<i>Ejemplo</i>: Creación dinámica de una estructura.
<program>
struct punto *new_punto(float x, float y)
  {
    struct punto *p;

    p=(struct punto *)malloc(sizeof(struct punto));
    p->x=x;
    p->y=y;

    return p;
  }
</program>
<p>
<b>Estructuras enlazadas</b>
<p>
<i>Ejemplo</i>: Un árbol binario.
<program arbol.c>
#include <stdio.h>
#include <string.h>

struct nodo
  {
    char *info;
    struct nodo *izq;
    struct nodo *der;
  };

struct nodo *new_nodo(char *s, struct nodo *i, struct nodo *d)
  {
    struct nodo *p;

    p=(struct nodo *)malloc(sizeof(struct nodo));
    p->izq=i;
    p->der=d;
    p->info=strdup(s);

    return p;
  }

void preorden(struct nodo *p)
  {
    if(p!=NULL)
      {
        printf("%s\n", p->info);
        preorden(p->izq);
        preorden(p->der);
      }
  }

/* Programa que crea un árbol pequeño y lo recorre en preorden */

main()
  {
    struct nodo *a;

    a=new_nodo("A",
        new_nodo("B", NULL, NULL),
        new_nodo("C",
            new_nodo("D", NULL, NULL),
            new_nodo("E", NULL, NULL)
        )
      );

    preorden(a);
  }
</program>
<p>
<h3>Sintaxis de la declaración de estructura</h3>
<p>
En C es posible declarar una estructura e inmediatamente declarar variables
que poseen esa estructura.
<i>Ejemplo</i>:
<program>
struct
  {
    float re;
    float im;
  } z, w;
</program>
<p>
Si queremos darle un nombre a la estructura, éste va después de la
palabra <tt><b>struct</b></tt>:
<program>
struct complex
  {
    float re;
    float im;
  } z, w;

struct complex u, v; /* utiliza la definición anterior */
</program>
<p>
También es posible no declarar ninguna variable al definir la estructura:
<p>
<program>
struct complex
  {
    float re;
    float im;
  };
 
struct complex z, w, u, v; /* utiliza la definición anterior */
</program>
<p>
<a name="15"><h2>Typedef</h2></a>
<p>
La palabra clave <tt><b>typedef</b></tt> se puede anteponer a una
declaración de variable y, en lugar de definir una variable, define
un nuevo nombre para ese tipo.
<i>Ejemplo</i>:
<program>
typedef int ENTERO;

ENTERO x; /* equivalente a int x; */
</program>
<p>
La principal utilidad de esto es darle nombre a tipos definidos
mediante estructuras:
<program>
typedef struct
  {
    float re;
    float im;
  } COMPLEX;

COMPLEX z, w;
</program>
<p>
No es posible utilizar un nombre definido por typedef dentro de la
misma definición.
Lo siguiente no funciona:
<program>
typedef struct
  {
    int info;
    NODO *izq;
    NODO *def;
  } NODO;
</program>
<p>
pero es posible definir el typedef primero y luego el contenido de la
estructura:
<program>
typedef struct nodo NODO;
 
struct nodo
  {
    int info;
    NODO *izq;
    NODO *der;
  };
</program>
<p>
<a name="16"><h2>Uniones</h2></a>
<p>
Una union es similar a una estructura, pero los campos están
superpuestos en memoria.
<p>
<i>Ejemplo</i>:
<p>
<program>
union
  {
    int ival;
    float fval;
  } u;
</program>
<p>
Los campos se accesan igual que en una estructura:
<program>
u.ival

u.fval
</program>
<p>
y es responsabilidad del programador asegurarse de que el campo tiene un
valor del tipo correcto.
Para esto a menudo se utiliza un campo adicional (fuera de la unión) llamado un <i>selector</i>.
<p>
<i>Ejemplo</i>:
<program union.c>
#include <stdio.h>

struct numero
  {
    int tipo; /* selector */
    union
      {
        int ival;
        float fval;
      } u;
  };

enum{INT, FLOAT}; /* Equivale a #define INT 0, #define FLOAT 1 */

void imprimir(struct numero a)
  {
    switch(a.tipo)
      {
    case INT:
        printf("%d\n", a.u.ival);
        break;

    case FLOAT:
        printf("%f\n", a.u.fval);
      }
  }

main()
  {
    struct numero x;

    x.tipo=INT;
    x.u.ival=5;
    imprimir(x);

    x.tipo=FLOAT;
    x.u.fval=3.14;
    imprimir(x);
  }
</program>
<p>
<a name="17"><h2>Entrada/Salida</h2></a>
<p>
Ya hemos visto las funciones básicas de entrada/salida de a un caracter
a la vez:
<program>
c=getchar();

putchar(c);
</program>
<p>
Para imprimir con formato:
<pre><b>
        printf(<i>formato</i>, <i>arg<sub>1</sub></i>, ...);
</b></pre>
<p>
<h3>Códigos de formato</h3>
<p>
<blockquote>
<table border=1>
<tr><td><tt><b>%d, %i</b></tt></td><td>decimal</td></tr>
<tr><td><tt><b>%o</b></tt></td><td>octal</td></tr>
<tr><td><tt><b>%x, %X</b></tt></td><td>hexadecimal</td></tr>
<tr><td><tt><b>%u</b></tt></td><td>unsigned</td></tr>
<tr><td><tt><b>%c</b></tt></td><td>caracter</td></tr>
<tr><td><tt><b>%s</b></tt></td><td>string</td></tr>
<tr><td><tt><b>%f</b></tt></td><td>flotante</td></tr>
<tr><td><tt><b>%e, %E</b></tt></td><td>flotante con exponente</td></tr>
<tr><td><tt><b>%g, %G</b></tt></td><td>flotante (general)</td></tr>
<tr><td><tt><b>%%</b></tt></td><td><tt><b>%</b></tt></td></tr>
</table>
</blockquote>
<p>
La función <tt><b>printf</b></tt> retorna el número de caracteres que
ha escrito.
<p>
La función <tt><b>sprintf</b></tt> es similar, pero escribe hacia un string, no hacia la salida:
<pre><b>
        <i>n</i> = sprintf(<i>s</i>, <i>formato</i>, <i>arg<sub>1</sub></i>, ...);
</b></pre>
<p>
La función opuesta es
<pre><b>
        <i>n</i> = scanf(<i>formato</i>, &<i>arg<sub>1</sub></i>, ...);
</b></pre>
<p>
Nótese que los parámetros son las direcciones de la variables cuyos valores
se leen bajo el control del formato.
<p>
También existe la función <tt><b>sscanf</b></tt>.
<p>
<h3>Acceso a Archivos</h3>
<p>
<pre><b>
        #include &lt;stdio.h>

        FILE *fp;  /* file pointer */

        fp=fopen(<i>nombre</i>, <i>modo</i>)
         /* <i>modo</i> = "r", "w", "a" */
         /* fopen retorna NULL en caso de error */

        fclose(fp);

        c=getc(fp);
        putc(c, fp);

        ungetc(c, fp);

        #define getchar()   getc(stdin)
        #define putchar(c)  putc((c), stdout)

        fprintf(fp, <i>formato</i>, ...);
        fscanf(fp, <i>formato</i>, ...);
</b></pre>
<p>
<i>Ejemplo</i>: Comando <tt><b>cat</b?</tt>
<p>
<program my_cat.c>
#include <stdio.h>

void filecopy(FILE *in, FILE *out)
  {
    int c;

    while((c=getc(in))!=EOF)
        putc(c, out);
  }

main(int argc, char *argv[])
  {
    FILE *fp;

    if(argc==1) /* sin argumentos */
        filecopy(stdin, stdout);
    else
        while(--argc>0)
            if((fp=fopen(*++argv, "r"))==NULL)
              {
                fprintf(stderr, "No se puede abrir archivo '%s'\n", *argv);
                exit(1);
              }
            else
              {
                filecopy(fp, stdout);
                fclose(fp);
              }
  }
</program>


<p>
<a name="18"><h2>setjmp/longjmp</h2></a>
<p>
Estas funciones permiten salirse desde el fondo de un conjunto
de llamadas a funciones:
<program>
#include <setjmp.h>

jmp_buf env;

if(setjmp(env)==0)
  {
    /* Aquí se ejecuta el proceso, el cual puede contener llamadas
       a funciones de cualquier nivel de profundida. En cualquier
       momento se puede ejecutar

               longjmp(env, val);

       Esto concluye abruptamente la ejecución y se retorna a la
       otra rama de este if
    */
  }
else
  {
    /* Aquí se llega después de que se ejecuta un longjmp en la otra
       rama del if. El segundo parámetro del longjmp se recibe como
       el valor retornado por el setjmp, y debe ser distinto de cero
    */
  }
</program>


<p>
<a name="19"><h2>Punteros a funciones</h2></a>
<p>
No existen variables de tipo "función", pero es posible tener una
variable que es un puntero a una función.
Esto es especialmente útil como parámetros para funciones.
<program qsort.c>
/* ordena datos de cualquier tipo usando Quicksort */

void swap(void *v[], int i, int j)
  {
    void *aux;

    aux=v[i];
    v[i]=v[j];
    v[j]=aux;
  }

void qsort(void *a[], int left, int right,
           int (*compare)(void *, void *))
  {
    int i, last;

    if(left>=right)
        return;

    swap(a, left, (left+right)/2);
    last=left;

    /*
          +--+-----------+--------+--------------+
          |  |///////////|\\\\\\\\|              |
          +--+-----------+--------+--------------+
          left        last         i         right
    */

    for(i=left+1; i<=right; ++i)
        if((*compare)(a[i], a[left])<0)
            swap(a, ++last, i);
    swap(a, left, last);

    qsort(a, left, last-1, compare);
    qsort(a, last+1, right, compare);
  }
</program>
<p>
El siguiente programa utiliza la función anterior para ordenar
líneas lexicográficamente:
<program ordena1.c>
#include <stdio.h>
#include <string.h>

#define ANCHO 1000
#define MAX 10000

main()
  {
    char s[ANCHO];
    char *linea[MAX];
    int i, j;
    void qsort(void **, int, int, int (*)(void *, void *));

    for(i=0; fgets(s, ANCHO, stdin)!=NULL; ++i)
        linea[i]=strdup(s);

    qsort((void **)linea, 0, i-1, strcmp);

    for(j=0; j<i; ++j)
        fputs(linea[j], stdout);
  }
</program>
<p>
Podemos hacer más general este programa si agregamos
una opción <tt><b>-n</b></tt> para pedir que la ordenación
sea en forma numérica:
<program ordena2.c>
#include <stdio.h>
#include <string.h>
 
#define ANCHO 1000
#define MAX 10000

int numcmp(char *s1, char *s2) /* compara numéricamente */
  {
    int i1, i2;

    i1=atoi(s1);
    i2=atoi(s2);

    return(i1<i2? -1 : i1==i2? 0 : 1);
  }
 
main(int argc, char *argv[])
  {
    char s[ANCHO];
    char *linea[MAX];
    int i, j, numeric=0;
    void qsort(void **, int, int, int (*)(void *, void *));

    numeric=(argc==2 && strcmp(argv[1], "-n")==0);
    if(argc>2|| argc==2 && !numeric)
      {
        fprintf(stderr, "Use: ordena [-n]\n");
        exit(1);
      }
 
    for(i=0; fgets(s, ANCHO, stdin)!=NULL; ++i)
        linea[i]=strdup(s);
 
    qsort((void **)linea, 0, i-1, (numeric?numcmp:strcmp));
 
    for(j=0; j<i; ++j)
        fputs(linea[j], stdout);
  }
</program>


<p>
<a name="20"><h2>Funciones con un número variable de parámetros</h2></a>
<p>
El siguiente ejemplo muestra como se puede escribir una función con
un número variable de parámetros, al estilo de <tt><b>printf</b></tt>:
<p>
<program printf.c>
#include <stdio.h>
#include <stdarg.h>

void miniprintf(char *fmt, ...)
  {
    va_list ap; /* argument pointer */
    char *p, *sval;
    int ival;
    double dval;

    va_start(ap, fmt); /* fmt es el último parámetro de la parte no variable */
    for(p=fmt; *p; ++p)
      {
        if(*p!='%')
          {
           putchar(*p);
           continue;
          }

        switch(*++p)
          {
        case 'd':
            ival=va_arg(ap, int);
            printf("%d", ival);
            break;

        case 'f':
            dval=va_arg(ap, double);
            printf("%f", dval);
            break;

        case 's':
            sval=va_arg(ap, char *);
            printf("%s", sval);
            break;

        default:
            putchar(*p);
            break;
          }
      }
    va_end(ap);
  }

main()
  {
    miniprintf("%s %d %f\n", "hola", 5, 3.14);
  }
</program>
<p>
<h3>Traspaso de parámetros a funciones del tipo <tt>printf</tt></h3>
<p>
Las funciones
<tt><b>vfprintf</b></tt>,
<tt><b>vprintf</b></tt> y
<tt><b>vsprintf</b></tt>
son similares a sus homólogas sin "v", pero reciben un puntero
<tt><b>ap</b></tt> en lugar de una lista variable.
Esto permite escribir una función similar a <tt><b>printf</b></tt>
que internamente llame a esta última.
<p>
<program subraya.c>
/* Imprime subrayando */

#include <stdio.h>
#include <stdarg.h>

void ulprintf(char *fmt, ...)
  {
    int n;
    va_list ap;

    va_start(ap, fmt);
    n=vprintf(fmt, ap);
    va_end(ap);

    while(--n>0)
        putchar('=');
    putchar('\n');
  }

main()
  {
    int a=5;
    float b=4.2;

    ulprintf("a=%d b=%3.1f\n", a, b);
    ulprintf("fin\n");
  }
</program>
<p>
<a name="21"><h2>La Biblioteca Standard de Entrada/Salida</h2></a>
<p>
A continuación veremos un resumen de las funciones disponibles:
<ul>
<p><li><tt><b>printf(<i>fmt</i>, <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ...)</b></tt><br>
<p><li><tt><b>fprintf(<i>stream</i>, <i>fmt</i>, <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ...)</b></tt><br>
<p><li><tt><b>vprintf(<i>fmt</i>, <i>ap</i>)</b></tt><br>
<p><li><tt><b>vfprintf(<i>stream</i>, <i>fmt</i>, <i>ap</i>)</b></tt><br>
<p><li><tt><b>fputs(<i>s</i>, <i>stream</i>)</b></tt><br>
= <tt><b>fprintf(<i>stream</i>, "%s", <i>s</i>)</b></tt>
<p><li><tt><b>puts(<i>s</i>)</b></tt><br>
= <tt><b>fprintf(stdout, "%s\n", <i>s</i>)   /* agrega \n */</b></tt>
<p><li><tt><b>fputc(<i>c</i>, <i>stream</i>)</b></tt><br>
<p><li><tt><b>putc(<i>c</i>, <i>stream</i>)   /* versión macro */</b></tt><br>
<p><li><tt><b>putchar(<i>c</i>)</b></tt><br>
<p><li><tt><b>fscanf(<i>stream</i>, <i>fmt</i>,
&amp;<i>a<sub>1</sub></i>, &amp;<i>a<sub>2</sub></i>, ...)</b></tt><br>
<p><li><tt><b><i>c</i>=fgetc(<i>stream</i>)</b></tt><br>
<p><li><tt><b><i>c</i>=getc(<i>stream</i>)   /* versión macro */</b></tt><br>
<p><li><tt><b><i>c</i>=getchar()</b></tt><br>
<p><li><tt><b>fgets(<i>s</i>, <i>n</i>, <i>stream</i>)</b></tt><br>
<p><li><tt><b>gets(<i>s</i>)   /* ¡peligrosa! */</b></tt><br>
<p><li><tt><b>ungetc(<i>c</i>, <i>stream</i>)</b></tt><br>
<p><li><tt><b><i>fp</i> = fopen(<i>path</i>, <i>mode</i>)</b></tt><br>
<blockquote>
<table border=1>
<tr><td><tt><b>"r"</b></tt></td><td>read</td></tr>
<tr><td><tt><b>"w"</b></tt></td><td>write</td></tr>
<tr><td><tt><b>"a"</b></tt></td><td>append</td></tr>
<tr><td><tt><b>"r+"</b></tt></td><td>update</td></tr>
<tr><td><tt><b>"w+"</b></tt></td><td>update (truncar primero)</td></tr>
<tr><td><tt><b>"a+"</b></tt></td><td>update (ir al final primero)</td></tr>
</table>
</blockquote>
<p><li><tt><b><i>nwritten</i>=fwrite(<i>ptr</i>, <i>size</i>, <i>nelems</i>, <i>stream</i>)</b></tt><br>
<p><li><tt><b><i>nread</i>=fread(<i>ptr</i>, <i>size</i>, <i>nelems</i>, <i>stream</i>)</b></tt><br>
<p><li><tt><b><i>status</i>=fseek(<i>stream</i>, <i>offset</i>, <i>how</i>)</b></tt><br>
<pre>
<b>
      long int offset;
      /* <i>status</i>==0 => OK, !=0 => error */
      /* <i>how</i> puede ser SEEK_SET, SEEK_END, SEEK_CUR */
</b>
</pre>
<p><li><tt><b><i>offset</i>=ftell(<i>stream</i>)</b></tt><br>
<p><li><tt><b>rewind(<i>stream</i>)</b></tt><br>
=<tt><b>(void)fseek(<i>stream</i>, 0L, SEEK_SET)</b></tt>
<p><li><tt><b><i>status</i>=fgetpos(<i>stream</i>, <i>pos</i>)</b></tt><br>
	<tt><b>fpos_t *pos;</b></tt>
<p><li><tt><b><i>status</i>=fsetpos(<i>stream</i>, <i>pos</i>)</b></tt><br>
<p><li><tt><b>fflush(<i>stream</i>)</b></tt><br>
	<tt><b><i>stream</i>==NULL => todos los streams abiertos</b></tt>
<p><li><tt><b>setvbuf(<i>stream</i>, <i>buf</i>, <i>mode</i>, <i>size</i>)</b></tt><br>
<pre>
<b>
    buf</i>==NULL => lo asigna el sistema
    <i>mode</i>==_IOFBF => fully buffered
    <i>mode</i>==_IOLBF => line buffered
    <i>mode</i>==_IONBF => no buffering
</b>
</pre>

</ul>

</BODY>
</HTML>
